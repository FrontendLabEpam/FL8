<!DOCTYPE html>
<html>
<head>
  <title>Functions</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link href="../assets/css/reset.css" rel="stylesheet" type="text/css" />
  <link href="../assets/css/fonts.css" rel="stylesheet" type="text/css" />
  <link href="../assets/css/typography.css" rel="stylesheet" type="text/css" />
  <link href="../assets/css/style.css" rel="stylesheet" type="text/css" />
</head>
<body>

<div class="wrapper">
  <header class="mainheader">
    <div class="logo">
      <div class="divider"><a href="../index.html"><img src="../assets/img/Logo.png"></a></div>
      <a href="../functions_pt1/index.html#1"><span class="logotext">Functions. Advanced.</span></a>
    </div>
  </header>
</div>
<!-- ================== Slides ================== -->
<textarea id="source">

class: center, middle

.title[
Front-end training
# Functions Advanced
]

---
  # Scope again

  1. Scope in an object, it's created at function call (activation object)
  2. All variables and functions become properties of scope object

  ```
    function parentFunction() {
        // parentFunction scope created. vairable and child function become its properties
        /*
            scope: {
              variable: undefined,
              childFunction: childFunction
            }
        */
        var variable = 10;
        function childFunction() {
              // Something useful here
        }

    }
    parentFunction();
  ```

---
# Function parent scope

### Function, as an object, has a special property [[Scope]].
### When function is **declared** - two things happen:<br>
  1. function becomes a property of scope object<br>
  2. current scope object is written to [[Scope]] property of function object<br>
<br>
```
    function parentFunction() {
        // parentFunction scope created.
        /*
            1. Child function becomes its property
            scope: {
              childFunction: childFunction
            }

            2. Scope becomes a property of child function
            childFunction.[[Scope]] = scope
        */
        function childFunction() {
              // Something useful here
        }
    }
    parentFunction();
```

---

# Closure

When function "knows" the scope where it was declared - we call it "closure"

```
    function parent() {
        var childCallCount = 0;
        function child() {
            childCallCount++;
            console.log(`called ${childCallCount} times`);
        }

        child();
        return child;
    }

    let childFirst = parent(); // called 1 time(s)
    childFirst(); // called 2 time(s)
    childFirst(); // called 3 time(s)

    let childSecond = parent();// called 1 time(s)
    childSecond(); // called 2 time(s)
    childSecond(); // called 3 time(s)

```

---

# Scope chain. Variable lookup

1. Folded functions create a chain of scopes
2. When we are trying to access a variable - JS will seek it in current scope and up through the chain
3. We can "hide" the parent variable by declaration a new variable with the same name
3. If no variable declaration were found - exception will occur
```
    function parent() {
        let parentProperty = 10;
        function child() {
            console.log(parentProperty);  // 10
        }
        child();

        function childHidesParentProperty() {
            let parentProperty = 20;
            function childOfAChild() {
                console.log(parentProperty); // 20
            }
            childOfAChild();
        }
        childHidesParentProperty();
    }
    parent();
```

---

# Parent scope is shared between child functions

It's really obvious, but let's see:
```
    function getCounter() {
        let counter = 0;
        function increment(incrementBy) {
            if (typeof incrementBy === 'undefined') {
                incrementBy = 1;
            }
            counter = counter + incrementBy;
        }
        function decrement(decrementBy) {
            if (typeof decrementBy !== 'number') {
                decrementBy = 1;
            }
            counter = counter - decrementBy;
        }
        function printCounter() {
            console.log('Current value is: ' + counter);
        }
        return {
            inc: increment,
            dec: decrement,
            print: printCounter
        }
    }

```
---
# Parent scope is shared between child functions (cont.)

```
    let counter = getCounter();
    counter.inc(10);
    counter.print(); // 11
    counter.dec();
    counter.print(); // 10
```
---
# Parent scope is shared between child functions ES6 example

```
    function getCounter() {
        let counter = 0;
        return {
            inc: (incrementBy = 1) => counter += incrementBy,
            dec: (decrementBy = 1) => counter -= decrementBy,
            print: () => console.log(`Current value is: ${counter}`)
        }
    }
    let counter = getCounter();
    counter.inc(10);
    counter.inc();
    counter.print(); // 11
    counter.dec();
    counter.print(); // 10
```

---

# Hoisting again.
1. var, let, const and function are hoisted
2. This is done to "hide" parent scope variables to avoid confusion (or to create one)
3. **var** is hoisted in a whole function scope

```
    var parentPropertyVar = 'var';

    function hoistingExample() {
        console.log('value: ', parentPropertyVar);  // undefined
        var parentPropertyVar = 'hidden var';
        console.log('value: ', parentPropertyVar); // 'hidden var'
    }

    console.log('value: ', parentPropertyVar); // var
    hoistingExample();
```

---

# Hoisting of let and const
1. **let** and **const** are hoisted in a block code scope: { ... }
2. Trying to access a variable before the declaration produces an error

```
    let parentPropertyLet = 'let';

    function hoistingExample(hideParentProperty) {
         if (hideParentProperty) {
            // console.log('value: ', parentPropertyLet);  -> will produce an error
            let parentPropertyLet = 'hidden let';
            console.log('value: ', parentPropertyLet);
        } else {
            console.log('value: ', parentPropertyLet);
        }
    }
    hoistingExample(false);
    hoistingExample(true);
```

---
# Summarize

1. Each function object gets a link to a scope where it is declared - closure
2. JS seek for variable value up through scopes chain
3. If we declare variable with the same name in child scope it will hide parent variable from us
4. But only in current function. Scope is shared between child functions, they will  have access to parent variable

---

# Call stack and recursion

Call stack holds the ordered list of called functions



---

# Function execution context. This.

The environment where function is executed is called **function execution context**
It consists of:
1. Function scope
2. Function parent scope (the whole chain)
3. "arguments" property
4. "this" keyword - often is called "function context"

```
    function showContext() {
        console.log(this);
    }
    showContext();
```

---



# Links

- https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures
- https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this
- https://developer.mozilla.org/ru/docs/Glossary/Call_stack
- http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/

</textarea>
<!-- ================== End of Slides ================== -->

    <script src="../assets/js/remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript">remark.create({
      highlightStyle: 'github',
      highlightLanguage: 'javascript'
    });</script>
</body>
</html>